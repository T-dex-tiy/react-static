'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var pathJoin = exports.pathJoin = function pathJoin() {
  for (var _len = arguments.length, paths = Array(_len), _key = 0; _key < _len; _key++) {
    paths[_key] = arguments[_key];
  }

  var newPath = ('' + paths.join('/')).replace(/\/{2,}/g, '/');
  if (newPath !== '/') {
    newPath = newPath.replace(/\/$/g, '');
  }
  return newPath;
};

// Normalize routes with parents, full paths, context, etc.
var normalizeRoutes = exports.normalizeRoutes = function normalizeRoutes(routes) {
  var flatRoutes = [];

  var recurse = function recurse(route) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { path: '/' };

    var path = pathJoin(parent.path, route.path);

    var normalizedRoute = _extends({}, route, {
      parent: parent,
      path: path,
      noIndex: typeof route.noIndex === 'undefined' ? parent.noIndex : route.noIndex
    });

    flatRoutes.push(normalizedRoute);

    if (route.children) {
      route.children.forEach(function (d) {
        return recurse(d, normalizedRoute);
      });
    }
  };
  routes.forEach(function (d) {
    return recurse(d);
  });
  flatRoutes.forEach(function (route) {
    var found = flatRoutes.find(function (d) {
      return d.path === route.path;
    });
    if (found !== route) {
      console.warn('More than one route is defined for path:', route.path);
    }
  });
  return flatRoutes;
};
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(pathJoin, 'pathJoin', 'src/shared.js');

  __REACT_HOT_LOADER__.register(normalizeRoutes, 'normalizeRoutes', 'src/shared.js');
}();

;